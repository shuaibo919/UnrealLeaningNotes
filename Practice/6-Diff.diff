diff --git a/Engine/Shaders/Private/BasePassVertexShader.usf b/Engine/Shaders/Private/BasePassVertexShader.usf
index 597b7246e..6fd49d648 100644
--- a/Engine/Shaders/Private/BasePassVertexShader.usf
+++ b/Engine/Shaders/Private/BasePassVertexShader.usf
@@ -8,6 +8,7 @@
 #include "SHCommon.ush"
 #include "VolumetricLightmapShared.ush"
 
+// 用于前向渲染的透明模式
 #if TRANSLUCENCY_PERVERTEX_FORWARD_SHADING
 #include "ReflectionEnvironmentShared.ush"
 
diff --git a/Engine/Shaders/Private/MyCustomVertexFactory.ush b/Engine/Shaders/Private/MyCustomVertexFactory.ush
index e69de29bb..78fba1392 100644
--- a/Engine/Shaders/Private/MyCustomVertexFactory.ush
+++ b/Engine/Shaders/Private/MyCustomVertexFactory.ush
@@ -0,0 +1,115 @@
+#include "/Engine/Private/VertexFactoryCommon.ush"
+
+// 1.定义FVertexFactoryInput，根据需要填充不同的数据
+struct FVertexFactoryInput
+{
+	float4	Position	: ATTRIBUTE0;
+	uint VertexId : SV_VertexID;
+	uint InstanceId	: SV_InstanceID;
+};
+
+// 2. VS到PS的数据
+struct FVertexFactoryInterpolantsVSToPS
+{
+	half4 Color	: COLOR0;
+	float2 TexCoords	: TEXCOORD0;																		
+};
+
+// 3. Intermediates的临时数据填充
+struct FVertexFactoryIntermediates
+{
+	float3	Position;
+	half4	Color;	
+
+	FSceneDataIntermediates SceneData;
+};
+
+// 4. 填充Intermediates
+FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
+{
+	FVertexFactoryIntermediates Intermediates = (FVertexFactoryIntermediates)0;
+	Intermediates.SceneData = VF_GPUSCENE_GET_INTERMEDIATES(Input);
+	Intermediates.Position = Input.Position.xyz;
+	Intermediates.Color = half4(0,0,0,1);
+	
+	return Intermediates;
+}
+
+// 5. Converts from vertex factory specific interpolants to a FMaterialPixelParameters, which is used by material inputs.
+FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
+{
+	// GetMaterialPixelParameters is responsible for fully initializing the result
+	FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();
+#if NUM_MATERIAL_TEXCOORDS
+	UNROLL
+	for (int CoordinateIndex = 0; CoordinateIndex < NUM_MATERIAL_TEXCOORDS; CoordinateIndex++)
+	{
+		Result.TexCoords[CoordinateIndex] = Interpolants.TexCoords;
+	}
+#endif
+	
+	Result.VertexColor = Interpolants.Color;
+	Result.TwoSidedSign = 1;
+	
+	return Result;
+}
+
+// 6. Converts from vertex factory specific input to a FMaterialVertexParameters, which is used by vertex shader material inputs
+FMaterialVertexParameters GetMaterialVertexParameters(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, half3x3 TangentToLocal)
+{
+	FMaterialVertexParameters Result = MakeInitializedMaterialVertexParameters();
+	
+	Result.WorldPosition = WorldPosition;
+	Result.TangentToWorld = mul(TangentToLocal, GetLocalToWorld3x3());
+	Result.VertexColor = Intermediates.Color;
+	Result.SceneData = Intermediates.SceneData;
+
+	return Result;
+}
+
+// 7. 用于从顶点着色器调用来获得世界空间的顶点位置。这个TransformLocalToTranslatedWorld是在VertexFactoryCommon里定义好的，直接调用
+float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
+{
+	return TransformLocalToTranslatedWorld(Intermediates.Position.xyz);
+}
+
+// 8. 直接返回即可，暂时对光栅化后的位置不做修改
+float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
+{
+	return InWorldPosition;
+}
+
+// 9. 组装Vertex Shader 到Pixel Shader中需要插值的变量
+FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
+{
+	FVertexFactoryInterpolantsVSToPS Interpolants;
+	Interpolants.Color = Intermediates.Color;
+	Interpolants.TexCoords = float2(0,0);
+	return Interpolants;
+}
+
+// 10. 获取上一帧世界位置，暂时直接返回
+float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
+{
+	return VertexFactoryGetWorldPosition(Input, Intermediates);
+}
+
+// 11. 直接抄的Engine/Plugins/Experimental/Water/Shaders/Private/WaterMeshVertexFactory.ush
+half3x3 VertexFactoryGetTangentToLocal( FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates )
+{
+	return half3x3(1,0,0,0,1,0,0,0,1);
+}
+
+// 12. 直接抄的Engine/Plugins/Experimental/Water/Shaders/Private/WaterMeshVertexFactory.ush
+float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
+{
+	// TODO: Central differencing to figure out the normal
+	return float3(0.0f, 0.0f, 1.0f);
+}
+
+FInstanceSceneData GetInstanceData(FVertexFactoryIntermediates Intermediates)
+{
+	return Intermediates.SceneData.InstanceData;
+}
+
+#include "VertexFactoryDefaultInterface.ush"
\ No newline at end of file
diff --git a/Engine/Shaders/Private/MyPostRendering.usf b/Engine/Shaders/Private/MyPostRendering.usf
index e69de29bb..d0a77e1ed 100644
--- a/Engine/Shaders/Private/MyPostRendering.usf
+++ b/Engine/Shaders/Private/MyPostRendering.usf
@@ -0,0 +1,32 @@
+﻿#include "Common.ush"
+Texture2D SceneColorTexture;
+SamplerState SceneColorSampler;
+
+#define MPR_BLUR_RADIUS 6
+
+void MainPS(
+noperspective float4 UVAndScreenPos: TEXCOORD0,
+float4 SvPosition:SV_POSITION,
+out float4 OutColor:SV_TARGET0)
+{
+	float2 UV = UVAndScreenPos.xy;
+	float3 Result = float3(0.,0.,0.);
+
+	uint Width, Height;
+	SceneColorTexture.GetDimensions(Width, Height);
+	float2 TexSize = 1.0f / float2(Width, Height);
+
+	for (int i = -MPR_BLUR_RADIUS; i < MPR_BLUR_RADIUS; ++i)
+	{
+		for ( int j = -MPR_BLUR_RADIUS; j < MPR_BLUR_RADIUS; ++j)
+		{
+			float2 SampledUV = UV + (float2(i, j) * TexSize);
+			Result += Texture2DSample(SceneColorTexture, SceneColorSampler, SampledUV).rgb;
+		}
+	}
+	
+	float3 BlurResult = Result / (float(MPR_BLUR_RADIUS) * float(MPR_BLUR_RADIUS) * 4.0f);
+	float3 OriginalColor = Texture2DSample(SceneColorTexture, SceneColorSampler, UV).rgb;
+
+	OutColor = float4(lerp(OriginalColor, BlurResult, step(0.5, UV.x)), 1.0);
+}
\ No newline at end of file
diff --git a/Engine/Shaders/Private/TempMeshPass.usf b/Engine/Shaders/Private/TempMeshPass.usf
index e69de29bb..22b83dbc8 100644
--- a/Engine/Shaders/Private/TempMeshPass.usf
+++ b/Engine/Shaders/Private/TempMeshPass.usf
@@ -0,0 +1,22 @@
+﻿#include "Common.ush"
+#include "/Engine/Generated/Material.ush"
+#include "/Engine/Generated/VertexFactory.ush"
+
+void MainVS(
+	FVertexFactoryInput Input,
+	out float4 OutPosition : SV_POSITION
+)
+{
+	ResolvedView =  (ResolveView());
+	FVertexFactoryIntermediates VFIntermediates = GetVertexFactoryIntermediates(Input);
+	float4 WorldPosition = VertexFactoryGetWorldPosition(Input, VFIntermediates);
+	float4 ClipSpacePosition = mul(WorldPosition, ResolvedView.TranslatedWorldToClip);
+	OutPosition = ClipSpacePosition;
+}
+
+void MainPS(
+	out float4 OutColor : SV_Target0
+)
+{
+	OutColor = float4(1,1,1,1);
+}
\ No newline at end of file
diff --git a/Engine/Source/Runtime/Engine/Classes/Components/MyCustomMeshComponent.h b/Engine/Source/Runtime/Engine/Classes/Components/MyCustomMeshComponent.h
index 6b6b1e9ed..e52a2ef00 100644
--- a/Engine/Source/Runtime/Engine/Classes/Components/MyCustomMeshComponent.h
+++ b/Engine/Source/Runtime/Engine/Classes/Components/MyCustomMeshComponent.h
@@ -13,6 +13,7 @@ class UMyCustomMeshComponent : public UMeshComponent
 {
 	GENERATED_BODY()
 	public:
+	
 	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Components|CustomAssetMesh")
 	bool bIsVisible;
 
@@ -24,7 +25,7 @@ class UMyCustomMeshComponent : public UMeshComponent
 
 	UPROPERTY()
 	TObjectPtr<UMaterialInterface> Material;
-
+	
 	//~ Begin UPrimitiveComponent Interface
 	ENGINE_API virtual FPrimitiveSceneProxy* CreateSceneProxy() override;
 	ENGINE_API virtual FBoxSphereBounds CalcBounds(const FTransform& LocalToWorld) const override;
diff --git a/Engine/Source/Runtime/Engine/Private/Components/MyCustomMeshComponent.cpp b/Engine/Source/Runtime/Engine/Private/Components/MyCustomMeshComponent.cpp
index e69de29bb..6885d938f 100644
--- a/Engine/Source/Runtime/Engine/Private/Components/MyCustomMeshComponent.cpp
+++ b/Engine/Source/Runtime/Engine/Private/Components/MyCustomMeshComponent.cpp
@@ -0,0 +1,252 @@
+#include "Components/MyCustomMeshComponent.h"
+
+#include "DataDrivenShaderPlatformInfo.h"
+#include "LandscapeGizmoActiveActor.h"
+#include "MaterialDomain.h"
+#include "MeshMaterialShader.h"
+#include "Materials/MaterialRenderProxy.h"
+#include "Serialization/JsonTypes.h"
+
+
+class FMyCustomVertexFactory: public FVertexFactory
+{
+	DECLARE_VERTEX_FACTORY_TYPE(FMyCustomVertexFactory)
+public:
+	FMyCustomVertexFactory(ERHIFeatureLevel::Type InFeatureLevel, const char* InDebugName)
+		: FVertexFactory(InFeatureLevel)
+	{
+		
+	}
+	
+
+	//~ Begin  FRenderResource interface
+	virtual void InitRHI(FRHICommandListBase& RHICmdList) override
+	{
+		// 顶点流， 类似于VertexShaderInputLayout的说明
+		FVertexStream PositionVertexStream;
+		PositionVertexStream.VertexBuffer = VertexBuffer;
+		PositionVertexStream.Stride = sizeof(FVector);
+		PositionVertexStream.Offset = 0;
+		PositionVertexStream.VertexStreamUsage = EVertexStreamUsage::Default;
+
+		const FVertexElement VertexPositionElement(Streams.Add(PositionVertexStream), 0, VET_Float3, 0, PositionVertexStream.Stride, false);
+
+		// 顶点声明
+		FVertexDeclarationElementList Elements;
+		Elements.Add(VertexPositionElement);
+
+		InitDeclaration(Elements);
+	}
+	
+	virtual void ReleaseRHI() override
+	{
+		UniformBuffer.SafeRelease();
+		FVertexFactory::ReleaseRHI();
+	}
+	//~ End  FRenderResource interface
+
+	static bool ShouldCompilePermutation(const FVertexFactoryShaderPermutationParameters& Parameters)
+	{
+		if ((Parameters.MaterialParameters.MaterialDomain == MD_Surface && Parameters.MaterialParameters.ShadingModels == MSM_Unlit)
+			|| Parameters.MaterialParameters.bIsDefaultMaterial)
+		{
+			return true;
+		}
+		return false;
+	}
+
+	static void ModifyComiplationEnvironment(const FVertexFactoryShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutShaderCompilerEnvironment)
+	{
+		const bool ContainsManualVertexFetch = OutShaderCompilerEnvironment.GetDefinitions().Contains("MANUAL_VERTEX_FETCH");
+		if (!ContainsManualVertexFetch)
+		{
+			OutShaderCompilerEnvironment.SetDefine(TEXT("MANUAL_VERTEX_FETCH"), 0);
+		}
+	
+		OutShaderCompilerEnvironment.SetDefine(TEXT("MY_CUSTOM_MESH"), 1);
+	}
+
+	FVertexBuffer *VertexBuffer = nullptr;
+	
+private:
+	FUniformBufferRHIRef UniformBuffer;
+	
+};
+
+IMPLEMENT_VERTEX_FACTORY_TYPE(FMyCustomVertexFactory, "/Engine/Private/MyCustomVertexFactory.ush", EVertexFactoryFlags::UsedWithMaterials)
+
+
+class FMyCustomSceneProxy final : public FPrimitiveSceneProxy
+{
+public:
+	SIZE_T GetTypeHash() const override
+	{
+		static size_t UniquePointer;
+		return reinterpret_cast<size_t>(&UniquePointer);
+	}
+	
+	FMyCustomSceneProxy(UMyCustomMeshComponent* InComponent)
+		: FPrimitiveSceneProxy(InComponent), bIsVisible(InComponent->bIsVisible), Material(	InComponent->Material),
+	MaterialRelevance(InComponent->GetMaterialRelevance(GetScene().GetFeatureLevel())), StaticMesh(InComponent->StaticMesh),
+	VertexFactory(GetScene().GetFeatureLevel(), "FCustomVertexFactory"),
+	Component(InComponent)
+	{
+		if (StaticMesh)
+		{
+			UpdateStaticMesh(StaticMesh);
+		}
+	}
+
+	virtual ~FMyCustomSceneProxy() override
+	{
+		VertexFactory.ReleaseResource();
+	}
+
+	virtual void GetDynamicMeshElements(const TArray<const FSceneView*>& Views, const FSceneViewFamily& ViewFamily, uint32 VisibilityMap, FMeshElementCollector& Collector) const override
+	{
+		if (!bIsVisible || !StaticMesh)
+		{
+			return;
+		}
+
+		// 生成MaterialProxy和线框
+		const bool bIsWireframe = AllowDebugViewmodes() && ViewFamily.EngineShowFlags.Wireframe;
+		FMaterialRenderProxy* WireframeMaterial = nullptr;
+		if (bIsWireframe)
+		{
+			WireframeMaterial = new FColoredMaterialRenderProxy(
+				GEngine->WireframeMaterial->GetRenderProxy(),
+				FLinearColor(0.2f, 0.5f, 1.0f));
+
+			Collector.RegisterOneFrameMaterialProxy(WireframeMaterial);
+		}
+		
+		if (StaticMesh)
+		{
+			const FStaticMeshRenderData* RenderData = StaticMesh->GetRenderData();
+			// 假设只有LOD0
+			for (int32 ViewIndex = 0; ViewIndex < Views.Num(); ++ViewIndex)
+			{
+				const FSceneView* View = Views[ViewIndex];
+				if (IsShown(View) && VisibilityMap & (1 << ViewIndex))
+				{
+					for (int32 LODIndex = 0; LODIndex < RenderData->LODResources.Num(); LODIndex++)
+					{
+						const FStaticMeshLODResources& LODModel = RenderData->LODResources[LODIndex];
+						for (int32 SectionIndex = 0; SectionIndex < LODModel.Sections.Num(); SectionIndex++)
+						{
+							UMaterialInterface* SectionMaterial = Component->GetMaterial(LODModel.Sections[SectionIndex].MaterialIndex) == nullptr ? UMaterial::GetDefaultMaterial(MD_Surface): Component->GetMaterial(SectionIndex);
+							FMaterialRenderProxy* MaterialRenderProxy = bIsWireframe ? WireframeMaterial : SectionMaterial->GetRenderProxy();
+
+							FMeshBatch& MeshBatch = Collector.AllocateMesh();
+							FMeshBatchElement& BatchElement = MeshBatch.Elements[0];
+							BatchElement.IndexBuffer = &LODModel.IndexBuffer;
+							MeshBatch.bWireframe = bIsWireframe;
+							MeshBatch.VertexFactory = &VertexFactory;
+							MeshBatch.MaterialRenderProxy = MaterialRenderProxy;
+
+							bool bHasPrecomputedVolumetricLightMap;
+							FMatrix PreviousLocalToWorldMatrix;
+							int32 SingleCaptureIndex;
+							bool bOutputVelocity;
+							GetScene().GetPrimitiveUniformShaderParameters_RenderThread(GetPrimitiveSceneInfo(), bHasPrecomputedVolumetricLightMap, PreviousLocalToWorldMatrix, SingleCaptureIndex, bOutputVelocity);
+							FDynamicPrimitiveUniformBuffer& DynamicPrimitiveUniformBuffer = Collector.AllocateOneFrameResource<FDynamicPrimitiveUniformBuffer>();
+							DynamicPrimitiveUniformBuffer.Set(Collector.GetRHICommandList(), GetLocalToWorld(), PreviousLocalToWorldMatrix, GetBounds(), GetLocalBounds(), true, bHasPrecomputedVolumetricLightMap, bOutputVelocity);
+							BatchElement.PrimitiveUniformBufferResource = &DynamicPrimitiveUniformBuffer.UniformBuffer;
+
+							BatchElement.FirstIndex = 0;
+							BatchElement.NumPrimitives = LODModel.IndexBuffer.GetNumIndices() / 3;
+							BatchElement.MinVertexIndex = 0;
+							BatchElement.MaxVertexIndex = LODModel.VertexBuffers.PositionVertexBuffer.GetNumVertices() - 1;
+							MeshBatch.ReverseCulling = IsLocalToWorldDeterminantNegative();
+							MeshBatch.Type = PT_TriangleList;
+							MeshBatch.DepthPriorityGroup = SDPG_World;
+							MeshBatch.bCanApplyViewModeOverrides = false;
+							Collector.AddMesh(ViewIndex, MeshBatch);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	virtual FPrimitiveViewRelevance GetViewRelevance(const FSceneView* View) const override
+	{
+		FPrimitiveViewRelevance Result;
+		Result.bDrawRelevance = IsShown(View) && bIsVisible;
+		Result.bShadowRelevance = false;
+		Result.bDynamicRelevance = true;
+		Result.bRenderInMainPass = true;
+		Result.bUsesLightingChannels = false;
+		Result.bRenderCustomDepth = false;
+		
+		MaterialRelevance.SetPrimitiveViewRelevance(Result);
+		
+		return Result;
+	}
+
+	virtual void CreateRenderThreadResources(FRHICommandListBase& RHICmdList) override
+	{
+		VertexFactory.InitResource(RHICmdList);
+	}
+
+	void UpdateStaticMesh(UStaticMesh* InMesh)
+	{
+		if(InMesh)
+		{
+			StaticMesh = InMesh;
+			VertexFactory.VertexBuffer = &StaticMesh->GetRenderData()->LODResources[0].VertexBuffers.PositionVertexBuffer;
+		}
+	}
+	
+	virtual uint32 GetMemoryFootprint(void) const override { return(sizeof(*this) + GetAllocatedSize()); }
+    	
+	uint32 GetAllocatedSize(void) const { return( FPrimitiveSceneProxy::GetAllocatedSize() ); }
+
+	
+	
+private:
+	bool bIsVisible;
+
+	UMaterialInterface* Material;
+	UStaticMesh* StaticMesh;
+	FMaterialRelevance MaterialRelevance;
+	FMyCustomVertexFactory VertexFactory;
+	UMyCustomMeshComponent* Component;
+};
+
+
+FPrimitiveSceneProxy* UMyCustomMeshComponent::CreateSceneProxy()
+{
+	return new FMyCustomSceneProxy(this);
+}
+
+FBoxSphereBounds UMyCustomMeshComponent::CalcBounds(const FTransform& LocalToWorld) const
+{
+	if (StaticMesh != nullptr)
+	{
+		// Graphics bounds.
+		FBoxSphereBounds NewBounds = StaticMesh->GetBounds().TransformBy(LocalToWorld);
+		NewBounds.BoxExtent *= BoundsScale;
+		NewBounds.SphereRadius *= BoundsScale;
+
+		return NewBounds;
+	}
+	else
+	{
+		return FBoxSphereBounds(LocalToWorld.GetLocation(), FVector::ZeroVector, 0.f);
+	}
+}
+
+int32 UMyCustomMeshComponent::GetNumMaterials() const
+{
+	return 1;
+}
+
+void UMyCustomMeshComponent::GetUsedMaterials(TArray<UMaterialInterface*>& OutMaterials, bool bGetDebugMaterials) const
+{
+	if (Material!=nullptr)
+	{
+		OutMaterials.Add(Material);
+	}
+}
\ No newline at end of file
diff --git a/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.cpp b/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.cpp
index 1f204a269..1c713d486 100644
--- a/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.cpp
+++ b/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.cpp
@@ -102,6 +102,8 @@
 #include "Rendering/CustomRenderPass.h"
 #include "EnvironmentComponentsFlags.h"
 
+#include "MyPostRendering.h"
+
 #if !UE_BUILD_SHIPPING
 #include "RenderCaptureInterface.h"
 #endif
@@ -2927,6 +2929,9 @@ void FDeferredShadingSceneRenderer::Render(FRDGBuilder& GraphBuilder)
 				bHeightFogHasComposedLocalFogVolume = bFogComposeLocalFogVolumes;
 			}
 
+			// Added by hushuaibo
+			RenderMyMeshPass(GraphBuilder, SceneTextures);
+
 			// Local Fog Volumes (LFV) rendering order is first HeightFog, then LFV, then volumetric fog on top.
 			// LFVs are rendered as part of the regular height fog + volumetric fog pass when volumetric fog is enabled and it is requested to voxelise LFVs into volumetric fog.
 			// Otherwise, they are rendered in an independent pass (this for instance make it independent of the near clip plane optimization).
@@ -3394,6 +3399,16 @@ void FDeferredShadingSceneRenderer::Render(FRDGBuilder& GraphBuilder)
 			}
 		}
 
+		if (ViewFamily.bResolveScene && ViewFamilyTexture)
+		{
+			for (int32_t i = 0; i < Views.Num(); ++i)
+			{
+				const FViewInfo& View = Views[i];
+				RenderMyPostEffect(GraphBuilder, View, ViewFamilyTexture);
+			}
+		}
+
+		
 		// After AddPostProcessingPasses in case of Lumen Visualizations writing to feedback
 		FinishGatheringLumenSurfaceCacheFeedback(GraphBuilder, Views[0], LumenFrameTemporaries);
 
diff --git a/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.h b/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.h
index b457bb986..1e00b3e64 100644
--- a/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.h
+++ b/Engine/Source/Runtime/Renderer/Private/DeferredShadingRenderer.h
@@ -321,6 +321,9 @@ public:
 	void InitializeRayTracingFlags_RenderThread();
 #endif
 
+	// Added by Hushuaibo
+	void RenderMyMeshPass(FRDGBuilder& GraphBuilder, const FMinimalSceneTextures& SceneTextures);
+	
 	FDeferredShadingSceneRenderer(const FSceneViewFamily* InViewFamily, FHitProxyConsumer* HitProxyConsumer);
 
 	/** Determine and commit the final state of the pipeline for the view family and views. */
diff --git a/Engine/Source/Runtime/Renderer/Private/MyPostRendering.cpp b/Engine/Source/Runtime/Renderer/Private/MyPostRendering.cpp
index fca151986..cdd1cf1f3 100644
--- a/Engine/Source/Runtime/Renderer/Private/MyPostRendering.cpp
+++ b/Engine/Source/Runtime/Renderer/Private/MyPostRendering.cpp
@@ -1 +1,65 @@
-﻿#include "MyPostRendering.h"
\ No newline at end of file
+﻿#include "MyPostRendering.h"
+#include "SceneRendering.h"
+#include "PixelShaderUtils.h"
+
+#define CLOSE_MY_POST_RENDERING
+
+class FMyPostRenderingPS : public FGlobalShader
+{
+	DECLARE_GLOBAL_SHADER(FMyPostRenderingPS);
+	SHADER_USE_PARAMETER_STRUCT(FMyPostRenderingPS, FGlobalShader);
+
+	BEGIN_SHADER_PARAMETER_STRUCT(FParameters, )
+		SHADER_PARAMETER_STRUCT_REF(FViewUniformShaderParameters, View)
+		SHADER_PARAMETER_RDG_TEXTURE(Texture2D, SceneColorTexture)
+		SHADER_PARAMETER_SAMPLER(SamplerState, SceneColorSampler)
+	END_SHADER_PARAMETER_STRUCT()
+};
+
+IMPLEMENT_GLOBAL_SHADER(FMyPostRenderingPS, "/Engine/Private/MyPostRendering.usf", "MainPS", SF_Pixel);
+
+BEGIN_SHADER_PARAMETER_STRUCT(FMyPostRenderingParameter, )
+	SHADER_PARAMETER_STRUCT_INCLUDE(FMyPostRenderingPS::FParameters, PS)
+	RENDER_TARGET_BINDING_SLOTS()
+END_SHADER_PARAMETER_STRUCT()
+
+
+
+void RenderMyPostEffect(FRDGBuilder & GraphBuilder, const FViewInfo& View, FRDGTextureRef ViewFamilyTexture)
+{
+#ifdef CLOSE_MY_POST_RENDERING
+	return ;
+#endif
+	FRDGTextureRef CopiedTexture = GraphBuilder.CreateTexture(ViewFamilyTexture->Desc, TEXT("CopiedTexture"));
+	AddCopyTexturePass(GraphBuilder, ViewFamilyTexture, CopiedTexture);
+
+	TShaderMapRef<FMyPostRenderingPS> PixelShader(View.ShaderMap);
+	FMyPostRenderingParameter *PassParameters = GraphBuilder.AllocParameters<FMyPostRenderingParameter>();
+	PassParameters->PS.View = View.ViewUniformBuffer;
+	PassParameters->PS.SceneColorSampler = TStaticSamplerState<SF_Point, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
+	PassParameters->PS.SceneColorTexture = CopiedTexture;
+	PassParameters->RenderTargets[0] = FRenderTargetBinding(ViewFamilyTexture, ERenderTargetLoadAction::ENoAction);
+
+	const FScreenPassTextureViewport Viewport(ViewFamilyTexture);
+	const TShaderMapRef<FScreenPassVS> VertexShader(GetGlobalShaderMap(View.GetFeatureLevel()));
+	FRHIBlendState* BlendState = FScreenPassPipelineState::FDefaultBlendState::GetRHI();
+	FRHIDepthStencilState* DepthStencilState = FScreenPassPipelineState::FDefaultDepthStencilState::GetRHI();
+
+	
+	ClearUnusedGraphResources(PixelShader, &PassParameters->PS);
+	
+	const FScreenPassPipelineState PipelineState(VertexShader, PixelShader, BlendState, DepthStencilState);
+	
+	GraphBuilder.AddPass(
+		RDG_EVENT_NAME("MyPostRendering"),
+		PassParameters,
+		ERDGPassFlags::Raster,
+		[ PipelineState, PixelShader, Viewport,  PassParameters](FRHICommandList& RHICmdList)
+	{
+		DrawScreenPass(RHICmdList, FScreenPassViewInfo(), Viewport, Viewport, PipelineState, EScreenPassDrawFlags::None, [&](FRHICommandList&)
+		{
+			SetShaderParameters(RHICmdList, PixelShader, PixelShader.GetPixelShader(), PassParameters->PS);
+		});
+	});
+	
+}
\ No newline at end of file
diff --git a/Engine/Source/Runtime/Renderer/Private/MyPostRendering.h b/Engine/Source/Runtime/Renderer/Private/MyPostRendering.h
index 288ba6a12..d4bf232ee 100644
--- a/Engine/Source/Runtime/Renderer/Private/MyPostRendering.h
+++ b/Engine/Source/Runtime/Renderer/Private/MyPostRendering.h
@@ -1,7 +1,5 @@
 ﻿#pragma once
-#include "GlobalShader.h"
+#include "CoreMinimal.h"
+#include "RendererInterface.h"
 
-class FMyPostRendering: public  FGlobalShader
-{
-	
-};
\ No newline at end of file
+void RenderMyPostEffect(FRDGBuilder & GraphBuilder, const FViewInfo& View, FRDGTextureRef ViewFamilyTexture);
\ No newline at end of file
diff --git a/Engine/Source/Runtime/Renderer/Private/SceneVisibility.cpp b/Engine/Source/Runtime/Renderer/Private/SceneVisibility.cpp
index 40d9d6e2d..934b89dec 100644
--- a/Engine/Source/Runtime/Renderer/Private/SceneVisibility.cpp
+++ b/Engine/Source/Runtime/Renderer/Private/SceneVisibility.cpp
@@ -1505,6 +1505,9 @@ void FRelevancePacket::ComputeRelevance(FDynamicPrimitiveIndexList& DynamicPrimi
 							bool bIsMeshInVelocityPass = false;
 							if (StaticMeshRelevance.bUseForMaterial && ViewRelevance.bRenderInMainPass)
 							{
+								//Added by Hushuaibo
+								DrawCommandPacket.AddCommandsForMesh(PrimitiveIndex, PrimitiveSceneInfo, StaticMeshRelevance, StaticMesh, CullingPayloadFlags, Scene, bCanCache, EMeshPass::TempMeshDraw);
+								
 								if (ViewRelevance.HasVelocity())
 								{
 									if (FVelocityMeshProcessor::PrimitiveHasVelocityForView(View, PrimitiveSceneProxy))
@@ -2263,6 +2266,11 @@ static void ComputeDynamicMeshRelevance(
 			}
 #endif
 
+			// Added by Hushuaibo
+			PassMask.Set(EMeshPass::TempMeshDraw);
+			View.NumVisibleDynamicMeshElements[EMeshPass::TempMeshDraw] += NumElements;
+		
+
 			if (ViewRelevance.bVelocityRelevance)
 			{
 				PassMask.Set(EMeshPass::Velocity);
diff --git a/Engine/Source/Runtime/Renderer/Private/TempMeshPass.cpp b/Engine/Source/Runtime/Renderer/Private/TempMeshPass.cpp
index e69de29bb..809431a52 100644
--- a/Engine/Source/Runtime/Renderer/Private/TempMeshPass.cpp
+++ b/Engine/Source/Runtime/Renderer/Private/TempMeshPass.cpp
@@ -0,0 +1,251 @@
+﻿#include "TempMeshPass.h"
+
+#include "DeferredShadingRenderer.h"
+#include "ScenePrivate.h"
+#include "SceneRendering.h"
+#include "Shader.h"
+#include "GlobalShader.h"
+#include "PipelineStateCache.h"
+#include "Materials/MaterialRenderProxy.h"
+#include "MeshPassProcessor.inl"
+
+class FTempMeshPassVS : public FMeshMaterialShader
+{
+    DECLARE_SHADER_TYPE(FTempMeshPassVS, MeshMaterial);
+public:
+    FTempMeshPassVS(){};
+    FTempMeshPassVS(const ShaderMetaType::CompiledShaderInitializerType& Initializer):FMeshMaterialShader(Initializer){}
+
+    static bool ShouldCompilePermutation(const FMeshMaterialShaderPermutationParameters& Parameters)
+    {
+       return true;
+    }
+};
+
+class FTempMeshPassPS : public FMeshMaterialShader
+{
+    DECLARE_SHADER_TYPE(FTempMeshPassPS, MeshMaterial);
+public:
+    FTempMeshPassPS(){};
+    FTempMeshPassPS(const ShaderMetaType::CompiledShaderInitializerType& Initializer):FMeshMaterialShader(Initializer){}
+
+    static bool ShouldCompilePermutation(const FMeshMaterialShaderPermutationParameters& Parameters)
+    {
+       return true;
+    }
+
+};
+
+IMPLEMENT_MATERIAL_SHADER_TYPE(, FTempMeshPassVS, TEXT("/Engine/Private/TempMeshPass.usf"), TEXT("MainVS"), SF_Vertex);
+IMPLEMENT_MATERIAL_SHADER_TYPE(, FTempMeshPassPS, TEXT("/Engine/Private/TempMeshPass.usf"), TEXT("MainPS"), SF_Pixel);
+
+
+//获取Shader实例
+bool GetTempMeshPassShaders(
+    const FMaterial& Material,
+    const FVertexFactoryType* VertexFactoryType,
+    ERHIFeatureLevel::Type FeatureLevel,
+    TShaderRef<FTempMeshPassVS>& VertexShader,
+    TShaderRef<FTempMeshPassPS>& PixelShader
+)
+{
+    FMaterialShaderTypes ShaderTypes;
+    ShaderTypes.AddShaderType<FTempMeshPassVS>();
+    ShaderTypes.AddShaderType<FTempMeshPassPS>();
+
+    FMaterialShaders Shaders;
+    if(!Material.TryGetShaders(ShaderTypes,VertexFactoryType, Shaders))
+    {
+       return false;
+    }
+
+    Shaders.TryGetVertexShader(VertexShader);
+    Shaders.TryGetPixelShader(PixelShader);
+    return true;
+}
+
+//根据一些条件筛选需要绘制的Material
+static bool ShouldDraw(const FMaterial& Material)
+{
+    return Material.GetShadingModels().HasShadingModel(MSM_Unlit);//选择带有Unlit Material的Mesh
+}
+
+FTempPassMeshProcessor::FTempPassMeshProcessor(const FScene* Scene, ERHIFeatureLevel::Type InFeatureLevel, const FSceneView* InViewIfDynamicMeshCommand, const FMeshPassProcessorRenderState& InPassDrawRenderState, FMeshPassDrawListContext* InDrawListContext)
+    :FMeshPassProcessor(EMeshPass::TempMeshDraw, Scene, InFeatureLevel, InViewIfDynamicMeshCommand, InDrawListContext)
+    ,PassDrawRenderState(InPassDrawRenderState)
+{}
+
+void FTempPassMeshProcessor::AddMeshBatch(const FMeshBatch& MeshBatch, uint64 BatchElementMask, const FPrimitiveSceneProxy* PrimitiveSceneProxy, int32 StaticMeshId)
+{
+    const FMaterialRenderProxy* MaterialRenderProxy = MeshBatch.MaterialRenderProxy;
+    while (MaterialRenderProxy)
+    {
+       const FMaterial* Material = MaterialRenderProxy->GetMaterialNoFallback(FeatureLevel);
+       if(Material)
+       {
+          if(TryAddMeshBatch(MeshBatch, BatchElementMask, PrimitiveSceneProxy, StaticMeshId, *MaterialRenderProxy, *Material))
+          {
+             break;
+          }
+       }
+
+       MaterialRenderProxy = MaterialRenderProxy->GetFallback(FeatureLevel);
+    }
+}
+
+bool FTempPassMeshProcessor::TryAddMeshBatch(const FMeshBatch& MeshBatch, uint64 BatchElementMask, const FPrimitiveSceneProxy* PrimitiveSceneProxy, int32 StaticMeshId, const FMaterialRenderProxy& MaterialRenderProxy, const FMaterial& Material)
+{
+    if(ShouldDraw(Material))
+    {
+       const FMeshDrawingPolicyOverrideSettings OverrideSettings = ComputeMeshOverrideSettings(MeshBatch);
+       const ERasterizerFillMode MeshFillMode = ComputeMeshFillMode(Material, OverrideSettings);
+       const ERasterizerCullMode MeshCullMode = ComputeMeshCullMode(Material, OverrideSettings);
+       return Process(MeshBatch, BatchElementMask, PrimitiveSceneProxy, StaticMeshId, MaterialRenderProxy, Material, MeshFillMode, MeshCullMode);
+    }
+    return true;
+}
+
+bool FTempPassMeshProcessor::Process(const FMeshBatch& MeshBatch, uint64 BatchElementMask, const FPrimitiveSceneProxy* PrimitiveSceneProxy, int32 StaticMeshId, const FMaterialRenderProxy& MaterialRenderProxy, const FMaterial& MaterialResource, ERasterizerFillMode MeshFillMode, ERasterizerCullMode MeshCullMode)
+{
+    const FVertexFactory* VertexFactory = MeshBatch.VertexFactory;
+
+    TMeshProcessorShaders<FTempMeshPassVS, FTempMeshPassPS> TempMeshPassShaders;
+
+    if(!GetTempMeshPassShaders(
+       MaterialResource,
+       VertexFactory->GetType(),
+       FeatureLevel,
+       TempMeshPassShaders.VertexShader,
+       TempMeshPassShaders.PixelShader
+    ))
+    {
+       return false;
+    }
+
+    FMeshMaterialShaderElementData ShaderElementData;
+    ShaderElementData.InitializeMeshMaterialData(ViewIfDynamicMeshCommand, PrimitiveSceneProxy, MeshBatch, StaticMeshId, false);
+
+    const FMeshDrawCommandSortKey SortKey = CalculateMeshStaticSortKey(TempMeshPassShaders.VertexShader, TempMeshPassShaders.PixelShader);
+
+    BuildMeshDrawCommands(
+       MeshBatch,
+       BatchElementMask,
+       PrimitiveSceneProxy,
+       MaterialRenderProxy,
+       MaterialResource,
+       PassDrawRenderState,
+       TempMeshPassShaders,
+       MeshFillMode,
+       MeshCullMode,
+       SortKey,
+       EMeshPassFeatures::Default,
+       ShaderElementData
+       );
+    return true;
+}
+
+void FTempPassMeshProcessor::CollectPSOInitializers(const FSceneTexturesConfig& SceneTexturesConfig, const FMaterial& Material, const FPSOPrecacheVertexFactoryData& VertexFactoryData, const FPSOPrecacheParams& PreCacheParams, TArray<FPSOPrecacheData>& PSOInitializers)
+{
+    if(!ShouldDraw(Material))
+    {
+       return;
+    }
+
+    TMeshProcessorShaders<FTempMeshPassVS, FTempMeshPassPS> TempMeshPassShaders;
+
+    if(!GetTempMeshPassShaders(
+       Material,
+       VertexFactoryData.VertexFactoryType,
+       FeatureLevel,
+       TempMeshPassShaders.VertexShader,
+       TempMeshPassShaders.PixelShader
+    ))
+    {
+       return;
+    }
+
+    const FMeshDrawingPolicyOverrideSettings OverrideSettings = ComputeMeshOverrideSettings(PreCacheParams);
+    const ERasterizerFillMode MeshFillMode = ComputeMeshFillMode(Material, OverrideSettings);
+    const ERasterizerCullMode MeshCullMode = ComputeMeshCullMode(Material, OverrideSettings);
+
+    FGraphicsPipelineRenderTargetsInfo RenderTargetsInfo;
+    RenderTargetsInfo.NumSamples = 1;
+
+    EPixelFormat SceneColorFormat = SceneTexturesConfig.ColorFormat;
+    ETextureCreateFlags SceneColorCreateFlags = SceneTexturesConfig.ColorCreateFlags;
+    AddRenderTargetInfo(SceneColorFormat, SceneColorCreateFlags, RenderTargetsInfo);
+
+    ETextureCreateFlags DepthStencilCreateFlags = SceneTexturesConfig.DepthCreateFlags;
+    SetupDepthStencilInfo(PF_DepthStencil, DepthStencilCreateFlags, ERenderTargetLoadAction::ELoad, ERenderTargetLoadAction::ELoad, FExclusiveDepthStencil::DepthRead_StencilWrite, RenderTargetsInfo);
+
+    AddGraphicsPipelineStateInitializer(
+       VertexFactoryData,
+       Material,
+       PassDrawRenderState,
+       RenderTargetsInfo,
+       TempMeshPassShaders,
+       MeshFillMode,
+       MeshCullMode,
+       (EPrimitiveType)PreCacheParams.PrimitiveType,
+       EMeshPassFeatures::Default,
+       true /*bRequired*/,
+       PSOInitializers
+    );
+}
+
+FMeshPassProcessor* CreateTempMeshPassProcessor(ERHIFeatureLevel::Type FeatureLevel, const FScene* Scene, const FSceneView* InViewIfDynamicMeshCommand, FMeshPassDrawListContext* InDrawListContext)
+{
+    const FExclusiveDepthStencil::Type SceneBaseDepthStencilAccess = FScene::GetDefaultBasePassDepthStencilAccess(FeatureLevel);
+
+    FMeshPassProcessorRenderState DrawRenderState;
+
+    FExclusiveDepthStencil::Type BasePassDepthStencilAccess_DepthWrite = FExclusiveDepthStencil::Type(SceneBaseDepthStencilAccess | FExclusiveDepthStencil::DepthWrite);
+
+    DrawRenderState.SetBlendState(TStaticBlendState<CW_RGBA, BO_Add, BF_One, BF_One, BO_Add, BF_Zero, BF_One>::GetRHI());
+    DrawRenderState.SetDepthStencilState(TStaticDepthStencilState<
+       true, CF_Always,
+       true, CF_Always, SO_Keep, SO_Keep, SO_Replace,
+       true, CF_Always, SO_Keep, SO_Keep, SO_Replace
+    >::GetRHI()
+    );
+
+    DrawRenderState.SetDepthStencilAccess(BasePassDepthStencilAccess_DepthWrite);
+    DrawRenderState.SetStencilRef(1);
+
+    return new FTempPassMeshProcessor(Scene, FeatureLevel, InViewIfDynamicMeshCommand, DrawRenderState, InDrawListContext);
+}
+
+REGISTER_MESHPASSPROCESSOR_AND_PSOCOLLECTOR(TempMeshPass, CreateTempMeshPassProcessor, EShadingPath::Deferred, EMeshPass::TempMeshDraw, EMeshPassFlags::MainView);
+
+
+BEGIN_SHADER_PARAMETER_STRUCT(FTempMeshPassParameters,)
+    SHADER_PARAMETER_STRUCT_INCLUDE(FViewShaderParameters, View)
+    SHADER_PARAMETER_STRUCT_INCLUDE(FInstanceCullingDrawParams, InstanceCullingDrawParams)
+    RENDER_TARGET_BINDING_SLOTS()
+END_SHADER_PARAMETER_STRUCT()
+
+void FDeferredShadingSceneRenderer::RenderMyMeshPass(FRDGBuilder& GraphBuilder, const FMinimalSceneTextures& SceneTextures)
+{
+    for(int32 ViewIndex = 0; ViewIndex < Views.Num(); ViewIndex++)
+    {
+       FViewInfo& View = Views[ViewIndex];
+
+       FTempMeshPassParameters* PassParameters = GraphBuilder.AllocParameters<FTempMeshPassParameters>();
+       PassParameters->View = View.GetShaderParameters();
+       PassParameters->RenderTargets[0] =  FRenderTargetBinding(SceneTextures.Color.Target, ERenderTargetLoadAction::ELoad);
+       PassParameters->RenderTargets.DepthStencil = FDepthStencilBinding(SceneTextures.Depth.Target, ERenderTargetLoadAction::ELoad, ERenderTargetLoadAction::ELoad, FExclusiveDepthStencil::DepthRead_StencilWrite);
+
+       View.ParallelMeshDrawCommandPasses[EMeshPass::TempMeshDraw].BuildRenderingCommands(GraphBuilder, Scene->GPUScene, PassParameters->InstanceCullingDrawParams);
+
+       GraphBuilder.AddPass(
+             RDG_EVENT_NAME("TempMeshPass"),
+             PassParameters,
+             ERDGPassFlags::Raster,
+             [this,&View, PassParameters](FRHICommandList& RHICmdList)
+          {
+             SetStereoViewport(RHICmdList, View);
+             View.ParallelMeshDrawCommandPasses[EMeshPass::TempMeshDraw].DispatchDraw(nullptr, RHICmdList, &PassParameters->InstanceCullingDrawParams);
+          });
+
+    }
+}
\ No newline at end of file
diff --git a/Engine/Source/Runtime/Renderer/Private/TempMeshPass.h b/Engine/Source/Runtime/Renderer/Private/TempMeshPass.h
index e69de29bb..76265588b 100644
--- a/Engine/Source/Runtime/Renderer/Private/TempMeshPass.h
+++ b/Engine/Source/Runtime/Renderer/Private/TempMeshPass.h
@@ -0,0 +1,41 @@
+#pragma once
+#include "CoreMinimal.h"
+#include "RendererInterface.h"
+#include "MeshPassProcessor.h"
+
+class FTempPassMeshProcessor : public FSceneRenderingAllocatorObject<FTempPassMeshProcessor>, public FMeshPassProcessor
+{
+public:
+	FTempPassMeshProcessor(
+		const FScene* Scene,
+		ERHIFeatureLevel::Type InFeatureLevel,
+		const FSceneView* InViewIfDynamicMeshCommand,
+		const FMeshPassProcessorRenderState& InPassDrawRenderState,
+		FMeshPassDrawListContext* InDrawListContext
+		);
+
+	virtual void AddMeshBatch(const FMeshBatch& MeshBatch, uint64 BatchElementMask, const FPrimitiveSceneProxy* PrimitiveSceneProxy, int32 StaticMeshId) override final;
+
+	virtual void CollectPSOInitializers(const FSceneTexturesConfig& SceneTexturesConfig, const FMaterial& Material, const FPSOPrecacheVertexFactoryData& VertexFactoryData, const FPSOPrecacheParams& PreCacheParams, TArray<FPSOPrecacheData>& PSOInitializers) override final;
+
+private:
+	bool TryAddMeshBatch(
+		   const FMeshBatch& RESTRICT MeshBatch,
+		   uint64 BatchElementMask,
+		   const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy,
+		   int32 StaticMeshId,
+		   const FMaterialRenderProxy& MaterialRenderProxy,
+		   const FMaterial& Material);
+
+	bool Process(
+	   const FMeshBatch& MeshBatch,
+	   uint64 BatchElementMask,
+	   const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy,
+	   int32 StaticMeshId,
+	   const FMaterialRenderProxy& RESTRICT MaterialRenderProxy,
+	   const FMaterial& RESTRICT MaterialResource,
+	   ERasterizerFillMode MeshFillMode,
+	   ERasterizerCullMode MeshCullMode);
+
+	FMeshPassProcessorRenderState PassDrawRenderState;
+};
\ No newline at end of file
diff --git a/Engine/Source/Runtime/Renderer/Public/MeshPassProcessor.h b/Engine/Source/Runtime/Renderer/Public/MeshPassProcessor.h
index dd3521f08..43b47061f 100644
--- a/Engine/Source/Runtime/Renderer/Public/MeshPassProcessor.h
+++ b/Engine/Source/Runtime/Renderer/Public/MeshPassProcessor.h
@@ -66,6 +66,9 @@ namespace EMeshPass
 		WaterInfoTextureDepthPass,
 		WaterInfoTexturePass,
 
+		// Added by Hushuaibo
+		TempMeshDraw,
+
 #if WITH_EDITOR
 		HitProxy,
 		HitProxyOpaqueOnly,
@@ -116,6 +119,8 @@ inline const TCHAR* GetMeshPassName(EMeshPass::Type MeshPass)
 	case EMeshPass::MeshDecal: return TEXT("MeshDecal");
 	case EMeshPass::WaterInfoTextureDepthPass: return TEXT("WaterInfoTextureDepthPass");
 	case EMeshPass::WaterInfoTexturePass: return TEXT("WaterInfoTexturePass");
+		// Added by Hushuaibo
+		case EMeshPass::TempMeshDraw: return TEXT("TempMeshDraw");
 #if WITH_EDITOR
 	case EMeshPass::HitProxy: return TEXT("HitProxy");
 	case EMeshPass::HitProxyOpaqueOnly: return TEXT("HitProxyOpaqueOnly");
@@ -125,9 +130,9 @@ inline const TCHAR* GetMeshPassName(EMeshPass::Type MeshPass)
 	}
 
 #if WITH_EDITOR
-	static_assert(EMeshPass::Num == 32 + 4, "Need to update switch(MeshPass) after changing EMeshPass"); // GUID to prevent incorrect auto-resolves, please change when changing the expression: {674D7D62-CFD8-4971-9A8D-CD91E5612CD8}
+	static_assert(EMeshPass::Num == 33 + 4, "Need to update switch(MeshPass) after changing EMeshPass"); // GUID to prevent incorrect auto-resolves, please change when changing the expression: {674D7D62-CFD8-4971-9A8D-CD91E5612CD8}
 #else
-	static_assert(EMeshPass::Num == 32, "Need to update switch(MeshPass) after changing EMeshPass"); // GUID to prevent incorrect auto-resolves, please change when changing the expression: {674D7D62-CFD8-4971-9A8D-CD91E5612CD8}
+	static_assert(EMeshPass::Num == 33, "Need to update switch(MeshPass) after changing EMeshPass"); // GUID to prevent incorrect auto-resolves, please change when changing the expression: {674D7D62-CFD8-4971-9A8D-CD91E5612CD8}
 #endif
 
 	checkf(0, TEXT("Missing case for EMeshPass %u"), (uint32)MeshPass);
